#version 450
#extension GL_EXT_scalar_block_layout : enable

layout(binding = 0) uniform sampler2D lowerMinMaxErrorMapMip;

layout(binding = 1, std430) buffer ConsumeNodeList 
{
	uint count;
	uvec2 data[];
} consumeNodeList;

layout(binding = 2, std430) buffer AppendNodeList 
{
	uint count;
	uvec2 data[];
} appendNodeList;

layout(binding = 3, std430) buffer FinalNodeList 
{
	uint count;
	uvec3 data[];
} finalNodeList;

layout(binding = 4, std430) uniform SceneData
{
	mat4 projectionMatrix;
	mat4 modelMatrix;
	mat4 viewMatrix;
	vec4 cameraPos;
	vec4 frustumPlanes[6];
};

// Same layout as VkDrawIndexedIndirectCommand
layout (binding = 5, std430) writeonly buffer IndexedIndirectCommand
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

layout (push_constant) uniform PushConstant
{
	uint lodLevel;
};

bool isPointOutSidePlane(vec4 plane, vec3 point)
{
	return dot(plane.xyz, point) + plane.w < 0;
}

bool isAABBOutSidePlane(vec4 plane, vec3 boundsMin, vec3 boundsMax)
{
	return isPointOutSidePlane(plane, boundsMin) &&
		isPointOutSidePlane(plane, boundsMax) &&
		isPointOutSidePlane(plane,vec3(boundsMin.x,boundsMin.y,boundsMax.z)) &&
		isPointOutSidePlane(plane,vec3(boundsMin.x,boundsMax.y,boundsMin.z)) &&
		isPointOutSidePlane(plane,vec3(boundsMin.x,boundsMax.y,boundsMax.z)) &&
		isPointOutSidePlane(plane,vec3(boundsMax.x,boundsMin.y,boundsMax.z)) &&
		isPointOutSidePlane(plane,vec3(boundsMax.x,boundsMax.y,boundsMin.z)) &&
		isPointOutSidePlane(plane,vec3(boundsMax.x,boundsMin.y,boundsMin.z));
}

// return false if AABB is out of frustum
 bool checkAABB(vec3 boundsMin, vec3 boundsMax)
 {
	for (uint i = 0; i < 6; ++i)
	{
		if (isAABBOutSidePlane(frustumPlanes[i], boundsMin, boundsMax))
		{
			return false;
		}
	}
	return true;
	
 }


 void traverseQuadTree(uint nodeX, uint nodeY)
 {

	ivec2 nodeIndex = consumeNodeList.data[]
 }

void main()
{
	ivec2 mapSize = textureSize(lowerMinMaxErrorMapMip, int(lodLevel));
	if (gl_GlobalInvocationID.x >= mapSize.x || gl_GlobalInvocationID.y >= mapSize.y)
	{
		return;
	}

}



