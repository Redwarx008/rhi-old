#version 450

layout(binding = 0, set = 0) uniform sampler2D heightmap;

layout(binding = 1, rgba32f) uniform writeonly image2D lowerMinMaxErrorMapMip;

layout(binding = 2, rgba32f) uniform writeonly image2D currentMinMaxErrorMapMip;

layout(binding = 3, std140) uniform UBO
{
	float heightScale;
	uint baseChunkSize;
};

layout(push_constant) uniform PushConstant
{
	uint currentLod;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

float getHeight(int x, int y)
{
	ivec2 heightmapSize = textureSize(heightmap, 0);

	x = clamp(x, 0, heightmapSize.x);
	y = clamp(y, 0, heightmapSize.y);
	vec2 uv = vec2(x, y) / heightmapSize;
	float height = texture(heightmap, uv).r * heightScale;
	return height;
}

void getAreaMinMaxHeight(int startX, int startY, int sizeX, int sizeY,
        out float minHeight, out float maxHeight)
{
	float minH = 999.0;
	float maxH = -1.0;

	for (int y = startY; y <= startY + sizeY; ++y)
	{
		for (int x = startX; x <= startX + sizeX; ++x)
		{
			float height = getHeight(x, y);
			minH = min(minH, height);
			maxH = max(maxH, height);
		}
	}

	minHeight = minH;
	maxHeight = maxH;
}

float getGeometricError(int startX, int startY, int sizeX, int sizeY)
{
	float maxError = 0.0;
    int stride = 1 << currentLod;
    int halfStride = stride / 2;

	for (int y = startY; y <= startY + sizeY; y += stride)
    {
        for (int x = startX + halfStride; x <= startX + sizeX - halfStride; x += stride)
        {
            float height = GetHeight(x, y);
            float left = GetHeight(x - halfStride, y);
            float right = GetHeight(x + halfStride, y);
            float simplifiedHeight = (left + right) / 2;
            float error = abs(simplifiedHeight - height);
            maxError = max(maxError, error);
        }
    }

    for (int y = startY + halfStride; y <= startY + sizeY - halfStride; y += stride)
    {
        for (int x = startX; x <= startX + sizeX; x += stride)
        {
            float height = GetHeight(x, y);
            float up = GetHeight(x, y + halfStride);
            float down = GetHeight(x, y - halfStride);
            float simplifiedHeight = (up + down) / 2;
            float error = abs(simplifiedHeight - height);
            maxError = max(maxError, error);
        }
    }

    for (int y = startY + halfStride; y <= startY + sizeY - halfStride; y += stride)
    {
        for (int x = startX + halfStride; x <= startX + sizeX - halfStride; x += stride)
        {
            float height = GetHeight(x, y);
            float upLeft = GetHeight(x - halfStride, y + halfStride);
            float downRight = GetHeight(x + halfStride, y - halfStride);
            float simplifiedHeight = (upLeft + downRight) / 2;
            float error = abs(simplifiedHeight - height);
            maxError = max(maxError, error);
        }
    }

    return maxError;
}


void createBaseMinMaxErrorMap(int chunkX, int chunkY)
{
    int startX = chunkX * baseChunkSize;
    int startY= chunkY * baseChunkSize;

    int chunkVertices = baseChunkSize + 1;

    float minHeight;
    float maxHeight;
    getAreaMinMaxHeight(startX, startY, chunkVertices, chunkVertices, minHeight, maxHeight);
    float error = getGeometricError(startX, startY, chunkVertices, chunkVertices);
    imageStore(currentMinMaxErrorMapMip, ivec2(chunkX, chunkY), vec4(minHeight, maxHeight, error, 1.0))
}

void createFromLowerMinMaxErrorMap(int chunkX, int chunkY)
{
    int lowerChunkX = chunkX << 1;
    int lowerChunkY = chunkY << 1;

    float minHeight = 999.0;
    float maxHeight = -1.0;
    for (int x = lowerChunkX; x < 2; ++x)
    {
        for (int y = lowerChunkY; y < 2; ++y)
        {
            vec2 minMax = imageLoad(lowerMinMaxErrorMapLevel, ivec2(x, y)).xy;
            minHeight = min(minHeight, minMax.x);
            maxHeight = max(maxHeight, minMax.y);
        }
    }

    int startX = chunkX * (baseChunkSize << currentLod);
    int startY = chunkY * (baseChunkSize << currentLod);
    int chunkVertices = baseChunkSize << currentLod + 1;
    float error = getGeometricError(startX, startY, chunkVertices, chunkVertices);
    imageStore(currentMinMaxErrorMapMip, ivec2(chunkX, chunkY), vec4(minHeight, maxHeight, error, 1.0))
}


void main()
{
	ivec2 minMaxErrorMapSize = textureSize(currentMinMaxErrorMapMip, 0);
    if (gl_GlobalInvocationID.x >= minMaxErrorMapSize.x || gl_GlobalInvocationID.y >= minMaxErrorMapSize.y)
    {
        return;
    }

    if (currentLod == 0)
    {
        createBaseMinMaxErrorMap(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    }
    else
    {
        createFromLowerMinMaxErrorMap(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    }
}
